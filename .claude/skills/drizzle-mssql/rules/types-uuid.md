---
title: MSSQL UUID Type
impact: HIGH
impactDescription: proper GUID/UUID handling with uniqueidentifier
tags: mssql, uuid, guid, uniqueidentifier
---

## MSSQL UUID Type

MSSQL uses `uniqueidentifier` for storing GUIDs/UUIDs. It's a 16-byte binary type with special handling for generation and comparison.

**Incorrect (using varchar for UUIDs):**

```typescript
export const records = mssqlTable('records', {
  // Storing UUID as string wastes space (36 chars vs 16 bytes)
  id: varchar('id', { length: 36 }).primaryKey(),
  // Inconsistent casing can cause comparison issues
  correlationId: varchar('correlation_id', { length: 36 }),
});
```

**Correct (using uniqueidentifier):**

```typescript
import { mssqlTable, int, uniqueIdentifier, varchar } from 'drizzle-orm/mssql-core';
import { sql } from 'drizzle-orm';

export const records = mssqlTable('records', {
  // uniqueidentifier is the native MSSQL type for UUIDs
  id: uniqueIdentifier('id').primaryKey().default(sql`NEWID()`),
  correlationId: uniqueIdentifier('correlation_id'),
  name: varchar('name', { length: 255 }).notNull(),
});
```

**UUID generation options:**

```typescript
import { sql } from 'drizzle-orm';

export const entities = mssqlTable('entities', {
  // NEWID() - Random UUID (version 4 style)
  id: uniqueIdentifier('id').primaryKey().default(sql`NEWID()`),

  // NEWSEQUENTIALID() - Sequential UUID, better for clustered index performance
  // Can only be used with DEFAULT constraint, not in INSERT
  sequentialId: uniqueIdentifier('sequential_id').default(sql`NEWSEQUENTIALID()`),
});
```

**JavaScript-generated UUIDs:**

```typescript
import { randomUUID } from 'crypto';

export const items = mssqlTable('items', {
  // Generate UUID in JavaScript
  id: uniqueIdentifier('id').primaryKey().$defaultFn(() => randomUUID()),
  name: varchar('name', { length: 255 }).notNull(),
});
```

**When to use uniqueidentifier vs int:**

```typescript
// Use uniqueidentifier for:
// - Distributed systems where IDs must be globally unique
// - Public-facing IDs (harder to guess/enumerate)
// - Merge replication scenarios
export const publicResources = mssqlTable('public_resources', {
  id: uniqueIdentifier('id').primaryKey().default(sql`NEWID()`),
  publicUrl: varchar('public_url', { length: 500 }),
});

// Use int/bigint for:
// - Internal primary keys with auto-increment
// - Better performance for clustered indexes
// - Smaller storage and faster joins
export const internalLogs = mssqlTable('internal_logs', {
  id: int('id').primaryKey(),  // With identity
  message: varchar('message', { length: 1000 }),
});

// Hybrid approach: int primary key + UUID for public exposure
export const orders = mssqlTable('orders', {
  id: int('id').primaryKey(),  // Internal, auto-increment
  publicId: uniqueIdentifier('public_id').notNull().unique().default(sql`NEWID()`),
  total: decimal('total', { precision: 10, scale: 2 }),
});
```

**Working with UUIDs in queries:**

```typescript
import { eq } from 'drizzle-orm';

// Insert with generated UUID
const newRecord = await db.insert(records).values({
  name: 'Test Record',
  // id will be auto-generated by NEWID()
});

// Query by UUID
const record = await db
  .select()
  .from(records)
  .where(eq(records.id, 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11'));
```

**Guidelines:**
- Use `uniqueIdentifier` instead of varchar for UUIDs - saves space and faster comparisons
- Use `NEWID()` for random UUIDs
- Use `NEWSEQUENTIALID()` for clustered primary keys - reduces page splits
- Consider int primary key + UUID public ID for best of both worlds
- UUIDs are case-insensitive in MSSQL
